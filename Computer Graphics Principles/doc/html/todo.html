<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Izg project 2017 - 2018: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Izg project 2017 - 2018
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000003"></a>Global <a class="el" href="group__gpu__side.html#ga3983ddd2c559c1a6d1e1f1f37be3eae0">gpu_computeGLVertexID</a>  (VertexIndex const *const indices, VertexShaderInvocation const vertexShaderInvocation)</dt>
<dd>Naimplementujte výpočet gl_VertexID z vertexShaderInvocation a případného indexování. vertexShaderInvocation obsahuje pořadové číslo spuštění (invokace) vertex shaderu v rámci jednoho vykreslovacího příkazu. gl_VertexID je index vertexu, který se má poslat do vertex shaderu - návratová hodnota této funkce. Pokud není aktivní indexing, index vertexu odpovída pořadovému číslu invokace vertex shaderu. Pokud je aktivní indexing, je potřeba zaadresovat správný gl_VertexID z bufferu indexů (indices) pomocí čísla invokace. Indexing je aktivní, pokud buffer indexů není NULL.  </dd>
<dt><a class="anchor" id="_todo000007"></a>Global <a class="el" href="group__gpu__side.html#gad1769dca11910a684a6ddaad188f3e3d">gpu_computeScreenSpaceBarycentrics</a>  (<a class="el" href="structVec3.html" title="This struct represents column 3D vector of 32-bt floats. ">Vec3</a> *const coords, <a class="el" href="structVec2.html" title="This struct represents column 2D vector of 32-bit floats. ">Vec2</a> const *const pixelCenter, <a class="el" href="structVec2.html" title="This struct represents column 2D vector of 32-bit floats. ">Vec2</a> const vertices[VERTICES_PER_TRIANGLE], <a class="el" href="structVec3.html" title="This struct represents column 3D vector of 32-bt floats. ">Vec3</a> const lines[EDGES_PER_TRIANGLE])</dt>
<dd>V této funkci spočtěte barycentrické coordináty trojúhelníku v obrazovce. Coordináty zapište do coords. V proměnné vertices naleznete pozice vrcholů ve 2D v obrazovce. V proměnné lines naleznete rovnice přímek hran trojúhelníka. Rovnice přímek jsou normalizované (velikost normály je 1). Normála směřuje směrem dovnitř trojúhelníka.  </dd>
<dt><a class="anchor" id="_todo000004"></a>Global <a class="el" href="group__gpu__side.html#ga4b894f26ed3c06346da10fc6c41f90eb">gpu_computeVertexAttributeDataPointer</a>  (<a class="el" href="structGPUVertexPullerHead.html" title="This struct represents configuration for one reading head of vertex puller. ">GPUVertexPullerHead</a> const *const head, VertexIndex const gl_VertexID)</dt>
<dd>Naimplementujte výpočet ukazatele pro daný vertex attribut a číslo vrcholu. Tato funkce počíta přesný ukazatel na data vertex atributu. Dejte si pozor na ukazatelovou aritmetiku, ukazatel musí být na byte přesně. Správná adresa se odvíjí od adresy bufferu, offsetu čtěcí hlavy, čísla vrcholu a kroku čtecí hlavy.  </dd>
<dt><a class="anchor" id="_todo000006"></a>Global <a class="el" href="group__gpu__side.html#ga5eb10381738a5e0426b2811820bc9483">gpu_runPrimitiveAssembly</a>  (GPU const gpu, <a class="el" href="structGPUPrimitive.html" title="This struct represents primitive - output of primitive assembly unit. A primitive is composed of N ve...">GPUPrimitive</a> *const primitive, size_t const nofPrimitiveVertices, <a class="el" href="structGPUVertexPullerConfiguration.html" title="represents configuration for vertex puller ">GPUVertexPullerConfiguration</a> const *const puller, VertexShaderInvocation const baseVertexShaderInvocation, VertexShader const vertexShader)</dt>
<dd>Naimplementujte funkci jednotky sestavující primitiva. Vašim úkolem je spustit vertex puller a dodaný vertex shader nad každým vrcholem primitiva. Funkce by měla spustit vertex puller/vertex shader N krát (podle množství vrcholů primitiva). Výstupy z vertex shaderu vložte do parametru primitive. Počet vrcholů primitiva je udán v nofPrimitiveVertices. Čislo invokace vertex shaderu pro první vrchol primitiva je v baseVertexShaderInvocation proměnné. Nezapomeňte spustit nad každým vrcholem primitiva vertex shader. Nezapomeňte do každého vrcholu správně zapsat číslo vrcholu (gl_VertexID)<br/>
 <b>Seznam funkcí, které jistě využijete:</b><ul>
<li><a class="el" href="group__gpu__side.html#ga0e0c36548db12eea1e6d512b9f855a1c" title="this function represents vertex puller ">gpu_runVertexPuller()</a></li>
<li><a class="el" href="group__gpu__side.html#ga3983ddd2c559c1a6d1e1f1f37be3eae0" title="This function computes gl_VertexID from vertex shader invocation using indexing. ">gpu_computeGLVertexID()</a><br/>
 <b>Seznam struktur, které jistě využijete:</b></li>
<li><a class="el" href="fwd_8h.html#a791f232eebdb273092201dacd9b3fd60" title="shortcut ">GPUVertexPullerOutput()</a></li>
<li><a class="el" href="fwd_8h.html#ac6b1d5e207ea5e4a8fc1208c7da10ffa" title="shortcut ">GPUVertexShaderInput()</a>  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000005"></a>Global <a class="el" href="group__gpu__side.html#ga0e0c36548db12eea1e6d512b9f855a1c">gpu_runVertexPuller</a>  (<a class="el" href="structGPUVertexPullerOutput.html" title="This struct represents output of vertex puller - vertex. ">GPUVertexPullerOutput</a> *const output, <a class="el" href="structGPUVertexPullerConfiguration.html" title="represents configuration for vertex puller ">GPUVertexPullerConfiguration</a> const *const puller, VertexShaderInvocation const vertexShaderInvocation)</dt>
<dd>Naimplementujte funkci vertex pulleru, využijte funkce gpu_computeGLVertexID a gpu_computeVertexAttrbuteDataPointer. Funkce vertex pulleru je nastavit správné adresy vertex attributů. Výstupem vertex pulleru je struktura obsahují seznam pointerů. Vašim úkolem je vypočítat správné adresy jednotlivých attributů. Pokud daný atribut/čtecí hlava není povolený/neexistuje nastavte jeho adresu na NULL.<br/>
 <b>Seznam funkcí, které jistě využijete:</b><ul>
<li><a class="el" href="group__gpu__side.html#ga3983ddd2c559c1a6d1e1f1f37be3eae0" title="This function computes gl_VertexID from vertex shader invocation using indexing. ">gpu_computeGLVertexID()</a></li>
<li><a class="el" href="group__gpu__side.html#ga4b894f26ed3c06346da10fc6c41f90eb" title="This function computes data pointer for vertex attribute &quot;attribute&quot; for vertex with index &quot;gl_Vertex...">gpu_computeVertexAttributeDataPointer()</a>  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000009"></a>Global <a class="el" href="group__shader__side.html#ga9cb61ad448e54a23ba4d01a6ebdb48eb">phong_fragmentShader</a>  (<a class="el" href="structGPUFragmentShaderOutput.html" title="This struct represents output data of fragment shader. ">GPUFragmentShaderOutput</a> *const output, <a class="el" href="structGPUFragmentShaderInput.html" title="This struct represents input data to fragment shader. ">GPUFragmentShaderInput</a> const *const input, GPU const gpu)</dt>
<dd>Naimplementujte fragment shader, který počítá phongův osvětlovací model s phongovým stínováním.<br/>
 <b>Vstup:</b><br/>
 Vstupní fragment by měl v nultém fragment atributu obsahovat interpolovanou pozici ve world-space a v prvním fragment atributu obsahovat interpolovanou normálu ve world-space.<br/>
 <b>Výstup:</b><br/>
 Barvu zapište do proměnné color ve výstupní struktuře.<br/>
 <b>Uniformy:</b><br/>
 Pozici kamery přečtěte z uniformní proměnné "cameraPosition" a pozici světla přečtěte z uniformní proměnné "lightPosition". Zachovejte jména uniformních proměnný. Pokud tak neučiníte, akceptační testy selžou.<br/>
 <br/>
 Dejte si pozor na velikost normálového vektoru, při lineární interpolaci v rasterizaci může dojít ke zkrácení. Zapište barvu do proměnné color ve výstupní struktuře. Shininess faktor nastavte na 40.f Difuzní barvu materiálu nastavte podle normály povrchu. V případě, že normála směřuje kolmo vzhůru je difuzní barva čistě bílá. V případě, že normála směřuje vodorovně nebo dolů je difuzní barva čiště zelená. Difuzní barvu spočtěte lineární interpolací zelené a bíle barvy pomocí interpolačního parameteru t. Interpolační parameter t spočtěte z y komponenty normály pomocí t = y*y (samozřejmě s ohledem na negativní čísla). Spekulární barvu materiálu nastavte na čistou bílou. Barvu světla nastavte na bílou. Nepoužívejte ambientní světlo.<br/>
 <b>Seznam funkcí, které jistě využijete</b>:<ul>
<li><a class="el" href="uniforms_8h.html#a0466fe65842b5a08561b87670f366f55" title="This function interprets uniform value as vec3. ">shader_interpretUniformAsVec3()</a></li>
<li><a class="el" href="program_8h.html#a132afaeef0a64d93305bb2df3f35a524" title="This function interprets fragment attribute of input fragment of fragment shader as vec3...">fs_interpretInputAttributeAsVec3()</a>  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000002"></a>Global <a class="el" href="group__cpu__side.html#gafea3b0614db94d611ae817685375c39c">phong_onDraw</a>  (SDL_Surface *surface)</dt>
<dd>Doprogramujte kreslící funkci. Zde byste měli aktivovat shader program, aktivovat vertex puller, nahrát data do uniformních proměnných a vykreslit trojúhelníky pomocí funkce cpu_drawTriangles. Data pro uniformní proměnné naleznete v externích globálních proměnnénych viewMatrix, projectionMatrix, cameraPosition a globální proměnné phong.lightPosition.<br/>
 <b>Seznam funkcí, které jistě využijete:</b><ul>
<li><a class="el" href="program_8h.html#a497d97730640942bffcc3cd9f266f146" title="This function activates selected program. ">cpu_useProgram()</a></li>
<li><a class="el" href="vertexPuller_8h.html#a27eee6237125ddc21c7d9b996f5af84e" title="This function activates vertex puller. ">cpu_bindVertexPuller()</a></li>
<li><a class="el" href="uniforms_8h.html#a44cfae8c541efcc181e3947511df7f7a" title="This function uploads 4x4 matrix to uniform variable in GPU memory. ">cpu_uniformMatrix4fv()</a></li>
<li><a class="el" href="uniforms_8h.html#abe070ee9f74f785a07118788fcf4219e" title="This function uploads three floats to uniform variable in GPU memory. ">cpu_uniform3f()</a></li>
<li><a class="el" href="student__pipeline_8c.html#aa47deaa10ce52221ab24e864a11426af" title="This function draw array of triangles. This function invokes whole rendering pipeline. It is necessary to active selected vertex puller and to active selected shader program before this function is called. ">cpu_drawTriangles()</a></li>
<li><a class="el" href="uniforms_8h.html#a6ea94982618b1c339a97a528b0670a53" title="This function returns location of reserved uniform variable. ">getUniformLocation()</a>  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000001"></a>Global <a class="el" href="group__cpu__side.html#gac2adb2ba4e748239b9db4d037584d3cc">phong_onInit</a>  (int32_t width, int32_t height)</dt>
<dd>Doprogramujte inicializační funkci. Zde byste měli vytvořit buffery na GPU, nahrát data do bufferů, vytvořit vertex puller a správně jej nakonfigurovat, vytvořit program, připojit k němu shadery a nastavit interpolace. Také byste zde měli zarezervovat unifromní proměnné pro matice, pozici kamery, světla a další vaše proměnné. Do bufferů nahrajte vrcholy králička (pozice, normály) a indexy na vrcholy ze souboru <a class="el" href="bunny_8h.html" title="This file contains model of Standford bunny in static arrays. ">bunny.h</a>. Shader program by měl odkazovat na funkce/shadery v souboru <a class="el" href="student__shader_8h.html" title="This file contains function declarations of vertex and fragment shader for phong shading/lighting. ">student_shader.h</a>. V konfiguraci vertex pulleru nastavte dvě čtecí hlavy. Jednu pro pozice vrcholů a druhou pro normály vrcholů. Nultý vertex/fragment atribut by měl obsahovat pozici vertexu. První vertex/fragment atribut by měl obsahovat normálu vertexu. Budete využívat minimálně 4 uniformní proměnné Uniformní proměnná pro view matici by měla být pojmenována "viewMatrix". Uniformní proměnná pro projekční matici by měla být pojmenována "projectionMatrix". Uniformní proměnná pro pozici kamery by se měla jmenovat "cameraPosition". Uniformní proměnná pro pozici světla by se měla jmenovat "lightPosition". Je důležité udržet pozice atributů a názvy uniformních proměnných z důvodu akceptačních testů. Interpolace vertex atributů do fragment atributů je také potřeba nastavit. Oba vertex atributy nastavte na <a class="el" href="program_8h.html#a8472f01c511d77bbfb981a46618ea1eaa33c7ccbb848d8fd75455dd9786a1153a">SMOOTH</a> interpolaci - perspektivně korektní interpolace.<br/>
 <b>Seznam funkcí, které jistě využijete:</b><ul>
<li><a class="el" href="uniforms_8h.html#acd308bcb7720918cb48f75292a247dfb" title="This functions reserves memory in GPU for uniform variable. ">cpu_reserveUniform()</a></li>
<li><a class="el" href="program_8h.html#a4fca7a0e3dac7f93620a1bde6efcde16" title="This function reserves id for new program. ">cpu_createProgram()</a></li>
<li><a class="el" href="program_8h.html#aaefc7833a6deea461cc06d00318f7975" title="This function attachs vertex shader to program. ">cpu_attachVertexShader()</a></li>
<li><a class="el" href="program_8h.html#a402ad69a9f1b80b8de408b991e190ed6" title="This function attachs fragment shader to program. ">cpu_attachFragmentShader()</a></li>
<li><a class="el" href="program_8h.html#aca1c5019ec58c919160c4c12a5e5fa06" title="This function sets interpolation of vertex attributes of output vertex. ">cpu_setAttributeInterpolation()</a></li>
<li><a class="el" href="buffer_8h.html#a6ba9c58dc4b7bc81e83d3dae3c6b292f" title="This function reserve buffer ids on GPU. ">cpu_createBuffers()</a></li>
<li><a class="el" href="buffer_8h.html#aad292278b58c11db74df3cb3e3a52f22" title="This function allocates/reallocates and uploads data to specific buffer on GPU. ">cpu_bufferData()</a></li>
<li><a class="el" href="vertexPuller_8h.html#a3b9678475f48f09c3ddbd4316fce3e08" title="This function reserve vertex puller ids on GPU. ">cpu_createVertexPullers()</a></li>
<li><a class="el" href="vertexPuller_8h.html#a07be46ae38b8ec80ec85581a33b02786" title="This function sets vertex attribute in vertex puller. ">cpu_setVertexPullerHead()</a></li>
<li><a class="el" href="vertexPuller_8h.html#afc4c70416bc0e515e75ec90c8c8d1584" title="This function enables vertex puller head. ">cpu_enableVertexPullerHead()</a></li>
<li><a class="el" href="vertexPuller_8h.html#aa312eaf555d453ead6a430f8f058c9a6" title="This function sets indexing in vertex puller. ">cpu_setIndexing()</a>  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000008"></a>Global <a class="el" href="group__shader__side.html#gabf238d989258c2c2e8e807e42e1c1404">phong_vertexShader</a>  (<a class="el" href="structGPUVertexShaderOutput.html" title="This struct represents vertex that is output of vertex shader. ">GPUVertexShaderOutput</a> *const output, <a class="el" href="structGPUVertexShaderInput.html" title="This struct represents input interface of vertex shader. ">GPUVertexShaderInput</a> const *const input, GPU const gpu)</dt>
<dd>Naimplementujte vertex shader, který transformuje vstupní vrcholy do clip-space.<br/>
 <b>Vstupy:</b><br/>
 Vstupní vrchol by měl v nultém atributu obsahovat pozici vrcholu ve world-space (vec3) a v prvním atributu obsahovat normálu vrcholu ve world-space (vec3).<br/>
 <b>Výstupy:</b><br/>
 Výstupní vrchol by měl v nultém atributu obsahovat pozici vrcholu (vec3) ve world-space a v prvním atributu obsahovat normálu vrcholu ve world-space (vec3). Výstupní vrchol obsahuje pozici a normálu vrcholu proto, že chceme počítat osvětlení ve world-space ve fragment shaderu.<br/>
 <b>Uniformy:</b><br/>
 Vertex shader by měl pro transformaci využít uniformní proměnné obsahující view a projekční matici. View matici čtěte z uniformní proměnné "viewMatrix" a projekční matici čtěte z uniformní proměnné "projectionMatrix". Zachovejte jména uniformních proměnných a pozice vstupních a výstupních atributů. Pokud tak neučiníte, akceptační testy selžou.<br/>
 <br/>
 Využijte vektorové a maticové funkce. Nepředávajte si data do shaderu pomocí globálních proměnných. Pro získání dat atributů použijte příslušné funkce vs_interpret* definované v souboru <a class="el" href="program_8h.html" title="This file contains structures and function declarations important for shader program object...">program.h</a>. Pro získání dat uniformních proměnných použijte příslušné funkce shader_interpretUniform* definované v souboru <a class="el" href="program_8h.html" title="This file contains structures and function declarations important for shader program object...">program.h</a>. Vrchol v clip-space by měl být zapsán do proměnné gl_Position ve výstupní struktuře.<br/>
 <b>Seznam funkcí, které jistě použijete</b>:<ul>
<li><a class="el" href="gpu_8h.html#a72dddc46dcba2d4e515fc23b61f0819a" title="This function returns handle to uniform values. ">gpu_getUniformsHandle()</a></li>
<li><a class="el" href="uniforms_8h.html#a6ea94982618b1c339a97a528b0670a53" title="This function returns location of reserved uniform variable. ">getUniformLocation()</a></li>
<li><a class="el" href="uniforms_8h.html#a83cb2c94ffb0623e9bb8d9508885376a" title="This function interprets uniform value as Mat4. ">shader_interpretUniformAsMat4()</a></li>
<li><a class="el" href="program_8h.html#a4bec56307c0d080bf314d20ff89773b2" title="This function interprets vertex attribute of input vertex of vertex shader as vec3. ">vs_interpretInputVertexAttributeAsVec3()</a></li>
<li><a class="el" href="program_8h.html#a60d0546dc8c052ee90f699ddca3b540b" title="This function interprets vertex attribute of output vertex of vertex shader as vec3. ">vs_interpretOutputVertexAttributeAsVec3()</a> </li>
</ul>
</dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 27 2018 09:09:28 for Izg project 2017 - 2018 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
